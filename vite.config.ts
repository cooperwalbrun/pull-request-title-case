import path, { resolve } from 'path';
import packageJson from './package.json';
import { defineConfig, Plugin } from 'vite';
import { existsSync, mkdirSync, writeFileSync } from 'fs';

const isFirefox = process.env.BROWSER === 'firefox';
const dist = resolve(__dirname, 'dist/' + (isFirefox ? 'firefox' : 'chrome'));
const prettyName = 'GitHub Pull Request Title Case Helper';

const extensionManifest = {
  // This object is a TypeScript implementation of the JSON schema documented here:
  // https://developer.chrome.com/docs/extensions/mv3/manifest/
  manifest_version: 3,
  name: prettyName,
  version: packageJson.version,
  description: packageJson.description, // Must be at most 132 characters long
  author: packageJson.author.name,
  homepage_url: packageJson.homepage,
  icons: {
    16: 'icons/icon-16x16.png',
    32: 'icons/icon-32x32.png',
    48: 'icons/icon-48x48.png', // This one is displayed in the Chrome Extensions Management page
    128: 'icons/icon-128x128.png',
    512: 'icons/icon-512x512.png'
  },
  action: {
    default_icon: {
      16: 'icons/icon-16x16.png',
      24: 'icons/icon-24x24.png',
      32: 'icons/icon-32x32.png'
    },
    default_title: prettyName,
    default_popup: 'popup.html'
  },
  incognito: 'spanning',
  content_scripts: [
    {
      matches: ['https://github.com/*'],
      js: ['js/content-script.js'],
      css: ['css/content-script.css']
    }
  ]
};

const firefoxManifestParts = {
  // This object is a TypeScript implementation of the JSON schema
  browser_specific_settings: {
    // browser_specific_settings is specific to Firefox - see:
    // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/browser_specific_settings
    gecko: {
      id: packageJson.name + '@cooperwalbrun.io',
      strict_min_version: '109.0' // v109.0 is when Manifest v3 support was added to Firefox
    }
  }
};

function generateManifest(outDir: string): Plugin {
  return {
    name: 'manifest-generator',
    writeBundle: async options => {
      // See: https://rollupjs.org/guide/en/#writebundle
      try {
        if (!existsSync(outDir)) {
          mkdirSync(outDir);
        }
        const destination = path.join(outDir, 'manifest.json');
        const manifest = {
          ...extensionManifest,
          ...(isFirefox ? firefoxManifestParts : {})
        };
        writeFileSync(destination, JSON.stringify(manifest, null, 2), {
          encoding: 'utf-8'
        });
        console.log(`Emitted ${destination}`);
      } catch (e) {
        console.error(e);
      }
    }
  };
}

export default defineConfig(config => ({
  root: 'src',
  publicDir: resolve(__dirname, 'src/assets'),
  esbuild: {
    // In Chrome, we are not allowed to minify the extension artifacts - see:
    // https://developer.chrome.com/docs/webstore/program_policies/#:~:text=Code%20Readability%20Requirements
    // However, in Firefox, we were forced to share the extension's full source code with Mozilla
    // due to the fact that we use a bundler (Vite/Rollup); since we shared the source with them, we
    // are completely free to minify the actual extension artifacts
    minifyIdentifiers: isFirefox
  },
  build: {
    outDir: dist,
    // Below, emptyOutDir must be set to false in order to prevent race conditions in the :dev flows
    // for Chrome/Firefox; in those flows, the build process is run in parallel with webext, and if
    // the files generated by this build process are not available by the time webext tries to serve
    // the extension, an error will occur. Instead of setting emptyOutDir here, we manually clean
    // the contents out of that directory at the appropriate times via a command defined directly in
    // package.json.
    emptyOutDir: false,
    rollupOptions: {
      input: {
        // These are regarded as the "roots" of the project: a compiled JavaScript file will be
        // generated for each entry below
        'content-script': resolve(__dirname, 'src/content-script.ts'),
        'popup': resolve(__dirname, 'src/popup.html')
      },
      output: {
        assetFileNames: assetInfo => {
          // This function removes the hash from generated stylesheets
          if (assetInfo.name.endsWith('css')) {
            return 'css/[name][extname]'; // [extname] is the file extension with a period
          } else {
            return assetInfo.name;
          }
        },
        entryFileNames: 'js/[name].js' // This removes the hash from generated JavaScript files
      }
    }
  },
  define: {
    EXTENSION_NAME: '"' + packageJson.name + '"',
    EXTENSION_VERSION: '"' + packageJson.version + '"'
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  plugins: [generateManifest(dist)]
}));
